---
export interface Props {
  href?: string;
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  glowColor?: string;
  particleEffect?: boolean;
  className?: string;
  type?: 'button' | 'submit' | 'reset';
  onClick?: string;
}

const {
  href,
  variant = 'primary',
  size = 'md',
  disabled = false,
  glowColor = '#00ff00',
  particleEffect = true,
  className = '',
  type = 'button',
  onClick
} = Astro.props;

const buttonId = 'button-' + Math.random().toString(36).substr(2, 9);

// Determine color based on variant
const variantColors = {
  primary: { bg: '#000000', text: glowColor, border: glowColor },
  secondary: { bg: 'transparent', text: glowColor, border: glowColor },
  danger: { bg: '#000000', text: '#ff0000', border: '#ff0000' }
};

const colors = variantColors[variant];

// Determine styles based on size
const sizeClasses = {
  sm: 'px-3 py-1 text-sm',
  md: 'px-4 py-2 text-base',
  lg: 'px-6 py-3 text-lg'
};

const baseClass = `
  relative inline-flex items-center justify-center
  pixel-border font-bold pixel-text
  transition-all duration-300
  ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer hover:scale-105'}
  ${sizeClasses[size]}
  ${className}
`;

const Tag = href ? 'a' : 'button';
---

<Tag
  {href}
  class={baseClass}
  data-button-id={buttonId}
  type={href ? undefined : type}
  {onClick}
  disabled={disabled}
  style={`
    background-color: ${colors.bg};
    color: ${colors.text};
    border-color: ${colors.border};
    box-shadow: 0 0 0 2px #000, 0 0 10px ${colors.border};
  `}
>
  <!-- Particle effect layer -->
  {particleEffect && !disabled && (
    <div class="absolute inset-0 pointer-events-none overflow-hidden rounded">
      <canvas class="button-particle-canvas w-full h-full" data-button-id={buttonId}></canvas>
    </div>
  )}

  <!-- Button content -->
  <span class="relative z-10 flex items-center gap-2">
    <slot />
  </span>

  <!-- Hover glow effect -->
  <div
    class="absolute inset-0 opacity-0 hover:opacity-100 transition-opacity duration-300 pointer-events-none rounded"
    style={`box-shadow: inset 0 0 15px ${colors.border};`}
  ></div>
</Tag>

<style>
  .pixel-text {
    font-family: 'Courier New', monospace;
    font-weight: bold;
    letter-spacing: 0.1em;
    text-shadow:
      1px 1px 0 #fff,
      -1px -1px 0 #000,
      1px -1px 0 #000,
      -1px 1px 0 #000;
  }

  .pixel-border {
    border: 2px solid;
  }

  /* Click ripple effect */
  .button-ripple {
    position: absolute;
    border-radius: 50%;
    background-color: currentColor;
    opacity: 0.3;
    transform: scale(0);
    animation: ripple 0.6s linear;
    pointer-events: none;
  }

  @keyframes ripple {
    to {
      transform: scale(4);
      opacity: 0;
    }
  }

  /* Disabled state styles */
  .cursor-not-allowed {
    cursor: not-allowed !important;
  }
</style>

<script define:vars={{ buttonId, glowColor, particleEffect, disabled }}>
  // Button particle effects
  if (particleEffect && !disabled) {
    class ButtonParticleEffect {
      constructor(buttonId, glowColor) {
        this.button = document.querySelector(`[data-button-id="${buttonId}"]`);
        this.canvas = this.button?.querySelector('.button-particle-canvas');
        this.ctx = this.canvas?.getContext('2d');
        this.glowColor = glowColor;
        this.particles = [];
        this.isHovered = false;

        this.init();
      }

      init() {
        if (!this.button || !this.canvas) return;

        // Set canvas dimensions
        const rect = this.button.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;

        // Event listeners
        this.button.addEventListener('mouseenter', () => this.handleHover(true));
        this.button.addEventListener('mouseleave', () => this.handleHover(false));
        this.button.addEventListener('click', (e) => this.handleClick(e));
      }

      handleHover(isHovered) {
        this.isHovered = isHovered;
        if (isHovered) {
          this.startHoverEffect();
        }
      }

      startHoverEffect() {
        if (!this.isHovered) return;

        // Create particles around button
        const rect = this.button.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;

        for (let i = 0; i < 3; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = 30 + Math.random() * 20;
          this.particles.push({
            x: centerX + Math.cos(angle) * distance,
            y: centerY + Math.sin(angle) * distance,
            vx: -Math.cos(angle) * 1,
            vy: -Math.sin(angle) * 1,
            size: Math.random() * 2 + 1,
            life: 1.0
          });
        }

        if (this.isHovered) {
          setTimeout(() => this.startHoverEffect(), 200);
        }
      }

      handleClick(e) {
        const rect = this.button.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Create explosion particle effect
        for (let i = 0; i < 12; i++) {
          const angle = (Math.PI * 2 * i) / 12;
          const velocity = 3 + Math.random() * 2;
          this.particles.push({
            x,
            y,
            vx: Math.cos(angle) * velocity,
            vy: Math.sin(angle) * velocity,
            size: Math.random() * 3 + 1,
            life: 1.0
          });
        }

        // Add ripple effect
        this.createRipple(x, y);
      }

      createRipple(x, y) {
        const ripple = document.createElement('div');
        ripple.className = 'button-ripple';
        ripple.style.cssText = `
          left: ${x - 25}px;
          top: ${y - 25}px;
          width: 50px;
          height: 50px;
        `;

        this.button.appendChild(ripple);
        setTimeout(() => ripple.remove(), 600);
      }

      update() {
        this.particles = this.particles
          .map(particle => ({
            ...particle,
            x: particle.x + particle.vx,
            y: particle.y + particle.vy,
            life: particle.life - 0.03
          }))
          .filter(particle => particle.life > 0);
      }

      draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        this.particles.forEach(particle => {
          this.ctx.save();
          this.ctx.globalAlpha = particle.life;
          this.ctx.fillStyle = this.glowColor;
          this.ctx.shadowBlur = 8;
          this.ctx.shadowColor = this.glowColor;

          const pixelSize = Math.max(1, Math.floor(particle.size));
          this.ctx.fillRect(
            Math.floor(particle.x / pixelSize) * pixelSize,
            Math.floor(particle.y / pixelSize) * pixelSize,
            pixelSize,
            pixelSize
          );

          this.ctx.restore();
        });
      }

      animate() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.animate());
      }
    }

    // Initialize button particle effects
    document.addEventListener('DOMContentLoaded', () => {
      new ButtonParticleEffect(buttonId, glowColor);
    });
  }
</script>